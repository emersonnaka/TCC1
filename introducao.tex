\chapter{Introdução}

	\ac{MOOC} é uma plataforma de ensino online
	com cursos massivos e abertos que visa oferecer os mais diversos cursos a nível
	global. Para realizar um curso ofertado pelo \acs{MOOC}, é necessário apenas a conexão
	com a Internet e o cadastro na plataforma, geralmente gratuito. Foi popularizado
	em 2011 quando grandes universidades, como Instituto de Tecnologia de
	Massachusetts (MIT), Universidade de Harvard e Universidade de Stanford, tiveram
	a iniciativa mediados pelos provedores Cousera, edX e Udacity, respectivamente
	\cite{Mehlenbacher:2012}. Além de permitir explorar novos modelos de negócio
	\cite{dellarocas2013money}, possibilita englobar mais alunos a custos menores
	e com boa qualidade \cite{schmidt2013producing}.
	
	Em cursos de introdução a programação, seja \acs{MOOC} ou presencial, há uma introdução
	sobre algoritmo seguido da seleção de uma linguagem de programação para
	desenvolvimento. Alguns desses cursos orientam a utilização de ferramentas, como
	o \acs{IDE} e ensinam o funcionamento da linguagem sintaticamente.
	Entretanto, esse tipo de ensino tem levado o estudante a fazer seu programa baseado
	na tentativa e erro, visto que buscam gerar o algoritmo sem o total conhecimento
	lógico do problema \cite{edwards2003}. Isso funcionou como um incentivo para que
	surgissem outras abordagens de ensino, como: baseado em jogos  (\acs{GBL} -- \acl{GBL}) \cite{kapp2012gamification},
	baseado em dicas \cite{glassman2016learnersourcing}, a reflexão na ação (\foreign{Reflection
	in action}) e o \acl{TDD} para ensino (\acs{TDD}) \cite{camara_graciottoSilva2016}.
	A \acs{GBL} utiliza recursos de jogos, como a pontução e o \foreign{ranking}, para motivar
	o estudante, podendo pontuar a cada problema resolvido, por exemplo. A segunda abordagem
	consiste na geração de dicas durante a resolução de um problema para ser apresentado
	a futuros estudantes. Na reflexão na ação, a
	implementação do \foreign{software} ocorre somente após o entendimento apropriado
	do problema \cite{edwards2004}. No \acs{TDD}, cumpre-se um ciclo dividido em três etapas:
	na primeira etapa o programador insere um teste que deve falhar no momento de sua
	execução; na segunda etapa é implementado a solução para que o caso de teste
	escrito anteriormente seja aceito; e a última etapa refere-se a refatoração
	(simplificar ou melhorar) o código recém implementado \cite{beck2003}.
	
	%TODO Criar um gancho de porquê as abordagens de reflexão na ação e TDD são interessantes p/ MOOC
	As abordagens \acl{TDD} e Reflexão na ação tornam-se interessantes para serem
	utilizadas em \acl{MOOC}, visto que ambas necessitam do entendimento do problema
	a ser resolvido, mesmo que de formas diferente. O \acl{TDD} necessita o entendimento
	do que não pode ser feito no problema, com isso, durante sua implementação, é
	possível realizar testes que possam falhar, caso viole alguma regra do problema.
	A Reflexão na ação é interessante devido às etapas impostas nessa abordagem.
	Dessa forma, é preciso entender o problema para que possa realizar as etapas
	corretamente. Ambas as abordagens evitam que os aprendizes tentem simplesmente
	programar e corrigi-los conforme os erros são apresentados. Dessa forma, desenvolvem
	o raciocínio lógico, a interpretação dos problemas e sua implementação.
	
	% Problema de pesquisa
	Principalmente em \acs{MOOC} de ensino de programação, tratando-se de uma ferramenta de
	ensino a nível mundial, deve-se considerar um grande número de usuários. Com isso,
	torna-se necessário a utilização de mecanismos de avaliação automática ou
	semiautomática \cite{schmidt2013producing}. Para alguns tipos de atividade, a
	avaliação automática é bem simples. Por exemplo, para verificar as soluções
	referentes às questões de múltipla escolha é necessário somente comparar a
	alternativa selecionada com o gabarito de questões \cite{alario2013analysing}. No
	entanto, implementações de programas computacionais necessitam que seus algoritmos
	sejam analisados quanto às saídas geradas pela sua execução, projeto do algoritmo,
	facilidade de compreensão, dentro outros requisitos, a fim de retornar o resultado
	da avaliação. Como há uma grande quantidade de submissões de trabalhos em cursos
	de programação, consequentemente acarreta alguns problemas como: avaliar todas as
	submissões, tempo e aumento de custo de correção por parte do professor.
	
	% Hipóteses
	
	% Justificativa
	
	% Objetivo
	Considerando que muitas atividades podem ser semelhantes, os professores podem explorar
	e compreender as variações de implementações enviados pelos estudantes \cite{Yin:2015}, a fim de diminuir
	o tempo gasto para correção dos códigos-fontes submetidos, por meio de agrupamentos
	(\foreign{clusters}). Por exemplo, tais agrupamentos podem ser realizados por meio
	da similaridade dos códigos. Compreendendo as variações de implementação, é possível
	extrair caraterísticas por meio da análise estática \cite{Yin:2015,Glassman:2014,Taherkhani:2012},
	análise dinâmica \cite{Glassman:2015} e análise do estilo de escrita \cite{Wei2015}.
	Com	isso, o agrupamento das submissões semelhantes infere na correção efetiva de
	poucos projetos, já que todos os outros códigos que estão no agrupamento serão
	parecidos, permitindo que o professor dedique o tempo poupado na correção de diversas
	implementações para aprimorar as correções de poucos trabalhos, possibilitando
	\foreign{feedbacks} mais precisos e menor custo para o \acs{MOOC}.
	
	
%	\citeonline{Yin:2015} extraem uma árvore de sintaxe abstrata de cada implementação
%	e verifica a similaridade par a par por meio da distância de edição de árvore. Tal
%	abordagem pode agrupar algoritmos corretos e incorretos, por exemplo: pode ocorrer
%	erro lógico e uma ou mais instruções estarem invertidas, o cálculo de similaridade
%	pode apontar que as implementações são semelhantes e agrupar códigos-fontes corretos
%	com incorretos. Entretanto, essa abordagem possui baixo custo computacional e
%	interessante para possibilidade de adaptação para verificar erros lógicos.
%	
%	\citeonline{Glassman:2014} extraem 60 características de submissões implementadas
%	em Python separadas em duas dimensões: alto nível e baixo nível. Realiza o agrupamento
%	utilizando as características de alto nível e, internamente desses agrupamentos,
%	executa o \foreign{k-means} novamente para as características de baixo nível. Apesar
%	de separar características de alto e baixo nível. Essa abordagem não considera as
%	chamadas de função e recursões, com isso o algoritmo, caso utilize essas instruções,
%	pode não ser classificado. Entretanto, o agrupamento em dois níveis é interessante
%	devido a possibilidade de obter agrupamentos com erros semelhantes apenas das
%	características de nível alto e, após a realização do segundo agrupamento, das
%	características de nível baixo, permitindo a realização do \foreign{feedback} em
%	duas etapas.
%	
%	\citeonline{Taherkhani:2012} apresentam a ferramenta Aari para classificar e reconhecer
%	algoritmos de ordenação. Para isso, extrai diversas características: numéricas,
%	descritivas, outras e de algoritmos de ordenação. Entretanto, é necessário que
%	treine a ferramenta para reconhecer os algoritmos desejados, caso contrário, o
%	classificador não estará apto e ocorrerá diversos erros de classificação. Sua
%	abordagem é interessante pelo fato de extrair características referente a recursão.
%	
%	\citeonline{Glassman:2015} apresentam a ferramenta OverCode que extrai características
%	por meio do histórico de execução da análise dinâmica. A similaridade das submissões
%	é realizada por meio da comparação entre blocos do programa. A partir disso é utilizado
%	o conceito de pilha para apresentar o agrupamentos das implementações semelhantes e,
%	ao clicar em um agrupamento, é possível verificar as linhas de código que formara
%	aquele agrupamento. Essa abordagem proporcionou o desenvolvimento de vários recursos
%	na ferramenta, como reescrever as variáveis que possuem a mesma atribuição, e mostrou
%	que a combinação de blocos de código e análise dinâmica pode produzir bons agrupamentos.
%	
%	\citeonline{Wei2015} realizam a extração de características por meio da normalização
%	do código-fonte e da análise do estilo de escrita. Para isso, separou cada implementação
%	em pedaços de código, condizentes a uma função, para verificar a similaridade entre eles.
%	Com isso, o instrutor corrigiria pedaços do código ao invés de corrigir todo o algoritmo.
%	O autor encontra a menor substring do bloco a partir de comparações \foreign{token} a
%	\foreign{token} para verificar a similaridade. Limitou-se a utilizar os pedaços de
%	código, sendo que poderia ter comparado com os agrupamentos considerando toda a
%	implementação. Entretanto, sua normalização foi interessante e a pouca quantidade de
%	características extraídas pode ter sido primordial para formar os agrupamentos.
	
	O objetivo deste trabalho foi estabelecer subsídios para a avaliação de
	programas submetidos em disciplinas introdutórias à computação, utilizando técnicas
	de mineração e visualização de dados para construir e apresentar agrupamentos de
	código-fonte semelhantes. Os seguintes subsídios foram investigados e desenvolvidos
	para a avaliação de programas submetidos em \acs{MOOC}:  % TODO: a concretização das metas gerarão/são os resultados/subsídios definidos no título do trabalho. Podemos deixar as metas mais claras nesse sentido e colocá-las como itemize.
	\begin{itemize}
		\item Agrupamento dos códigos-fontes semelhantes, utilizando técnicas de mineração;
		\item Seleção de uma técnica de projeção adequado para o mapeamento dos \foreign{clusters};
		\item Ferramenta de visualização;
		\item Material para os professores sobre como corrigir as submissões utilizando a ferramenta.
	\end{itemize}
	
	Como metas, estabeleceu-se
	o desenvolvimento de uma ferramenta para recuperação de dados a partir de
	códigos-fontes e da alteração de uma ferramenta para mineração e visualização de % TODO: apresentar esta ferramenta (Python), como fruto de trabalhos anteriores e utilizadas no presente trabalho
	dados \cite{Alencar-etal:2012}. Para minerar os dados, foi realizado modificações no
	código-fonte do \texttt{Flake8} \cite{flake8} e no \texttt{PEP8} \cite{pep8} para
	que fosse possível armazenar a extração de características em um arquivo. Encontrar
	e modificar essas ferramentas foi fruto de trabalhos anteriores a serem utilizados
	no presente trabalho. Com o auxílio dessas ferramentas, foram investigadas as
	características e técnicas para mineração e visualização dos programas submetidos,
	avaliando-se como contribuir para a correção dos trabalhos submetidos, o tempo em  % TODO: podemos relatar apenas o tempo para correção e a qualidade dos agrupamentos, mas não da qualidade de feedback.
	que foi necessário para que os professores corrigissem todas as submissões e a
	qualidade dos agrupamentos realizados pelo sistema.
	
	% TODO: reescrever este parágrafo para mostrar os resultados do trabalho.
	Por meio desses subsídios buscamos diminuir o tempo gasto na correção de todos os
	códigos-fontes referente às atividades de Introdução a Ciência da Computação e fornecer
	\foreign{feedbacks} construtivos para o professor de modo que ele consiga corrigir
	uma quantidade menor do total de implementações submetidas, produzindo correções
	relevantes para todos os usuários.
	
	O restante desta proposta de trabalho de conclusão de curso é organizado da seguinte
	forma. O \cref{chap:Ref} apresenta o referencial teórico sobre: \acs{MOOC} e visualização,
	além dos trabalhos relacionados à visualização e avaliação de implementações submetidos
	em \acs{MOOC}. O \cref{chap:metodo-ferramentas} apresenta o método de pesquisa, a estratégia
	para avaliação e as ferramentas modificadas e utilizados. O \cref{chap:resultados} descreve
	dois estudos sobre a utilização da ferramenta. O
	\cref{chap:Conclusao} conclui este estudo, apresentando considerações finais e trabalhos
	futuros.
