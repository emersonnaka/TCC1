\chapter{Introdução}

	MOOC - \foreign{Massive Open Online Course} - é uma plataforma de ensino online
	com cursos massivos e abertos que visa oferecer os mais diversos cursos a nível global.
	Foi popularizado em 2011 quando grandes universidades, como o Instituto de Tecnologia de
	Massachusetts, a Universidade de Harvard e a Universidade de Stanford, tiveram a
	iniciativa mediado pelos provedores Cousera, edX e Udacity \cite{Mehlenbacher:2012}.
	Além de permitir explorar novos modelos de negócio \cite{dellarocas2013money},
	possibilita englobar mais alunos a custos menores e com a qualidade desejada
	\cite{schmidt2013producing}. Para realizar um curso ofertado pelo MOOC, é necessário
	apenas a conexão com a Internet e o cadastro na plataforma que é realizado gratuitamente.
	Essa plataforma é uma forma de ensino a	distância, oferecendo a liberdade dos usuários
	planejarem seus horários que realizarão as aulas. 
	
	% Problema de pesquisa
	Tratando-se de uma ferramenta de ensino a nível mundial, deve-se considerar um
	grande número de usuários. Com isso, torna-se necessário a utilização de mecanismos
	de avaliação automática ou semiautomática \cite{schmidt2013producing}. Apesar de
	existir formas de avaliação automática para questões de múltipla escolha
	\cite{alario2013analysing}, por exemplo. Implementações de programa computacionais
	necessitam que seus algoritmos sejam corrigidos ao invés das saídas geradas pela sua
	execução a fim de retornar o resultado da avaliação para que o usuário possa
	implementá-lo novamente. Como há uma grande quantidade de submissões de trabalhos em
	cursos de programação, visto que, a cada turma de um curso, existem atividades a
	serem feitas e entregues por meio da plataforma de ensino. Desta forma, há uma grande
	quantidade de projetos a serem corrigidos e, consequentemente, acarreta alguns
	problemas como: avaliar todas as submissões, tempo e aumento de custo de correção por
	parte do professor e do assistente de ensino (\foreign{teaching assistant} – TA).
	
	% Hipóteses
	
	% Justificativa
	Corrigir cada submissão individualmente, além de cansar o TA, gera um custo maior
	para a organização responsável pelo MOOC, visto que, quanto o maior o tempo gasto
	para correção das implementações, maior será o valor pago ao profissional. Com
	isso, o agrupamento das submissões semelhantes infere na correção de poucos
	projetos, já que todos os outros códigos que estão no agrupamento serão
	parecidos, podendo melhorar a qualidade de vida do TA, a eficiência da correção
	por meio de \foreign{feedbacks} mais precisos e menor custo para o MOOC.
	
	% Objetivo
	Considerando que muito projetos podem ser semelhantes, os professores e os TAs podem
	explorar e compreender as variações de implementações \cite{Yin:2015}, a fim de
	diminuir o tempo gasto para correção dos códigos fontes submetidos, por meio de
	agrupamentos (\foreign{clusters}). Por exemplo, tais agrupamentos podem ser
	realizados por meio da similaridade dos códigos e agrupados com um algoritmo como
	o \foreign{k-means}. Compreendendo as variações de implementação, \citeonline{Yin:2015},
	\citeonline{Glassman:2014} e \citeonline{Taherkhani:2012} extraem características
	por meio da análise estática, \citeonline{Glassman:2015} utiliza a análise dinâmica,
	enquanto \citeonline{Wei2015} extraem as características analisando o estilo de escrita.
	
	\citeonline{Yin:2015} extrai uma árvore de sintaxe abstrata de cada implementação
	e verifica a similaridade par a par por meio da distância de edição de árvore. Tal
	abordagem pode agrupar algoritmos corretos e incorretos, por exemplo: pode ocorrer
	erro lógico e uma ou mais instruções estarem invertidas, o cálculo de similaridade
	pode apontar que as implementações são semelhantes e agrupar códigos-fontes corretos
	com incorretos. Entretanto, essa é uma abordagem possui baixo custo computacional e
	interessante para possibilidade de adaptação para verificar erros lógicos.
	
	\citeonline{Glassman:2014} extrai 60 características de submissões implementadas
	em Python separadas em duas dimensões: alto nível e baixo nível. Realiza o agrupamento
	utilizando as características de alto nível e, internamente desses agrupamentos,
	executa o \foreign{k-means} novamente para as características de baixo nível. Apesar
	de separar características de alto e baixo nível. Essa abordagem não considera as
	chamadas de função e recursões, com isso o algoritmo, caso utilize essas instruções,
	pode não ser classificado. Entretanto, o agrupamento em dois níveis é interessante
	devido a possibilidade de obter agrupamentos com erros semelhantes apenas das
	características de nível alto e, após a realização do segundo agrupamento, das
	características de nível baixo, permitindo a realização do \foreign{feedback} em
	duas etapas.
	
	\citeonline{Taherkhani:2012} apresenta a ferramenta Aari para classificar e reconhecer
	algoritmos de ordenação. Para isso, extrai diversas características: numéricas,
	descritivas, outras e de algoritmos de ordenação. Entretanto, é necessário que
	treine a ferramenta para reconhecer os algoritmos desejados, caso contrário, o
	classificador não estará apto e ocorrerá diversos erros de classificação. Sua
	abordagem é interessante pelo fato de extrair características referente a recursão.
	
	\citeonline{Glassman:2015} apresenta a ferramenta OverCode que extrai características
	por meio do histórico de execução da análise dinâmica. A similaridade das submissões
	é realizada por meio da comparação entre blocos do programa. A partir disso é utilizado
	o conceito de pilha para apresentar o agrupamentos das implementações semelhantes e,
	ao clicar em um agrupamento, é possível verificar as linhas de código que formara
	aquele agrupamento. Essa abordagem proporcionou o desenvolvimento de vários recursos
	na ferramenta, como reescrever as variáveis que possuem a mesma atribuição, e mostrou
	que a combinação de blocos de código e análise dinâmica pode produzir bons agrupamentos.
	
	\citeonline{Wei2015} realiza a extração de características por meio da normalização
	do código-fonte e da análise do estilo de escrita. Para isso, separou cada implementação
	em pedaços de código, condizentes a uma função, para verificar a similaridade entre eles.
	Com isso, o instrutor corrigiria pedaços do código ao invés de corrigir todo o algoritmo.
	O autor encontra a menor substring do bloco a partir de comparações \foreign{token} a
	\foreign{token} para verificar a similaridade. Limitou-se a utilizar os pedaços de
	código, sendo que poderia ter comparado com os agrupamentos considerante toda a
	implementação. Entretanto, sua normalização foi interessante e a pouca quantidade de
	características extraídas pode ter sido primordial para formar os agrupamentos.
	
%	Como \citeonline{Yin:2015} considera apenas as produções atribuídas a árvore, pode
%	ocorrer dos agrupamentos possuírem implementações corretas e incorretas devido ao
%	cálculo de similaridade utilizado
	
	Considerando este cenário, o objetivo deste trabalho é propor subsídios para a
	avaliação de programas submetidos, utilizando técnicas de mineração e visualização
	de dados com a finalidade de diminuir o tempo gasto na correção de todos os códigos
	fontes e  fornecer \foreign{feedbacks} construtivos de modo que o usuário consiga
	corrigir seus erros e submeta novamente seu algoritmo. Especificamente, serão
	considerados cursos introdutórios de Computação com a linguagem Python. Como
	metas, estabeleceu-se o desenvolvimento de uma ferramenta para recuperação de
	dados a partir de códigos fonte em Python e da alteração de uma ferramenta para
	mineração e visualização de dados~\cite{Alencar}. Com o auxílio dessas ferramentas,
	serão investigadas as características e técnicas para mineração e visualização
	dos programas submetidos, avaliando-se como o quanto ele pode contribuir para
	a correção dos códigos fontes submetidos, o tempo em que foi necessário para
	que os assistentes corrigirem todas as submissões e a qualidade dos agrupamentos
	realizados pelo sistema.
	
	Após o desenvolvimento do sistema, avaliaremos o quanto ele pode contribuir para
	a correção dos códigos fontes submetidos, o tempo em que foi necessário para que
	os assistentes corrijam todas as submissões e a qualidade dos agrupamentos
	realizados pelo sistema.
	
	O trabalho de conclusão de curso é organizado da seguinte forma: o Capítulo
	\ref{chapterRef} apresenta o referencial teórico, divido pela Seção \ref{sectionFund}
	que apresenta alguns termos técnicos utilizados e suas definições e a Seção
	\ref{sectionTrab} descreve os trabalhos relacionados que fundamentaram o projeto.
	O Capítulo \ref{chapterProp} apresenta a metodologia de pesquisa para obter os
	resultados, seguido do Capítulo \ref{chapterResult} que possui os resultados
	preliminares.